%top{
#include "ZlangParser.yy.hpp"    /* Generated by bison. */
#include "location.yy.hpp"  /* Generated by bison %locations. */

#include <stdio.h>

    #define MAKE_TOKEN(__token_name__) \
        return Zlang::ZlangParser::make_##__token_name__(location())

    #define MAKE_STR_TOKEN(__token_name__) \
        return Zlang::ZlangParser::make_##__token_name__(str(), location())

    #define MAKE_SYM_TOKEN(__symbol__) \
        return Zlang::ZlangParser::symbol_type((__symbol__), location())
%}

%option exception="Zlang::ZlangParser::syntax_error(location(), \"Unknown token.\");"

O   [0-7]
D   [0-9]
NZ  [1-9]
L   [a-zA-Z_]
A   [a-zA-Z_0-9]
H   [a-fA-F0-9]
HP  (0[xX])
E   ([Ee][+-]?{D}+)
P   ([Pp][+-]?{D}+)
FS  (f|F|l|L)
IS  (((u|U)(l|L|ll|LL)?)|((l|L|ll|LL)(u|U)?))
CP  (u|U|L)
SP  (u8|u|U|L)
ES  (\\(['"\?\\abfnrtv]|[0-7]{1,3}|x[a-fA-F0-9]+))
WS  [ \t\v\n\f]

%%
"/*"                    { /*comment();*/ }
"//".*                  { /* consume //-comment */ }
"#".*                   { /* Preprocessor directive */ }

"auto"					{ MAKE_TOKEN(AUTO); }
"break"					{ MAKE_TOKEN(BREAK); }
"case"					{ MAKE_TOKEN(CASE); }
"char"					{ MAKE_TOKEN(CHAR); }
"const"					{ MAKE_TOKEN(CONST); }
"continue"				{ MAKE_TOKEN(CONTINUE); }
"default"				{ MAKE_TOKEN(DEFAULT); }
"do"					{ MAKE_TOKEN(DO); }
"double"				{ MAKE_TOKEN(DOUBLE); }
"else"					{ MAKE_TOKEN(ELSE); }
"enum"					{ MAKE_TOKEN(ENUM); }
"extern"				{ MAKE_TOKEN(EXTERN); }
"float"					{ MAKE_TOKEN(FLOAT); }
"for"					{ MAKE_TOKEN(FOR); }
"goto"					{ MAKE_TOKEN(GOTO); }
"if"					{ MAKE_TOKEN(IF); }
"inline"				{ MAKE_TOKEN(INLINE); }
"int"					{ MAKE_TOKEN(INT); }
"long"					{ MAKE_TOKEN(LONG); }
"register"				{ MAKE_TOKEN(REGISTER); }
"restrict"				{ MAKE_TOKEN(RESTRICT); }
"return"				{ MAKE_TOKEN(RETURN); }
"short"					{ MAKE_TOKEN(SHORT); }
"signed"				{ MAKE_TOKEN(SIGNED); }
"sizeof"				{ MAKE_TOKEN(SIZEOF); }
"static"				{ MAKE_TOKEN(STATIC); }
"struct"				{ MAKE_TOKEN(STRUCT); }
"switch"				{ MAKE_TOKEN(SWITCH); }
"typedef"				{ MAKE_TOKEN(TYPEDEF); }
"union"					{ MAKE_TOKEN(UNION); }
"unsigned"				{ MAKE_TOKEN(UNSIGNED); }
"void"					{ MAKE_TOKEN(VOID); }
"volatile"				{ MAKE_TOKEN(VOLATILE); }
"while"					{ MAKE_TOKEN(WHILE); }

"_Alignas"              { MAKE_TOKEN(ALIGNAS); }
"_Alignof"              { MAKE_TOKEN(ALIGNOF); }
"_Atomic"               { MAKE_TOKEN(ATOMIC); }
"_Bool"                 { MAKE_TOKEN(BOOL); }
"_Complex"              { MAKE_TOKEN(COMPLEX); }
"_Generic"              { MAKE_TOKEN(GENERIC); }
"_Imaginary"            { MAKE_TOKEN(IMAGINARY); }
"_Noreturn"             { MAKE_TOKEN(NORETURN); }
"_Static_assert"        { MAKE_TOKEN(STATIC_ASSERT); }
"_Thread_local"         { MAKE_TOKEN(THREAD_LOCAL); }
"__func__"              { MAKE_TOKEN(FUNC_NAME); }

{L}{A}*	                { MAKE_TOKEN(IDENTIFIER); }

{HP}{H}+{IS}?			        { MAKE_TOKEN(I_CONSTANT); }
{NZ}{D}*{IS}?			        { MAKE_TOKEN(I_CONSTANT); }
"0"{O}*{IS}?			        { MAKE_TOKEN(I_CONSTANT); }
{CP}?"'"([^'\\\n]|{ES})+"'"     { MAKE_TOKEN(I_CONSTANT); }

{D}+{E}{FS}?				{ MAKE_TOKEN(F_CONSTANT); }
{D}*"."{D}+{E}?{FS}?		{ MAKE_TOKEN(F_CONSTANT); }
{D}+"."{E}?{FS}?			{ MAKE_TOKEN(F_CONSTANT); }
{HP}{H}+{P}{FS}?			{ MAKE_TOKEN(F_CONSTANT); }
{HP}{H}*"."{H}+{P}{FS}?		{ MAKE_TOKEN(F_CONSTANT); }
{HP}{H}+"."{P}{FS}?			{ MAKE_TOKEN(F_CONSTANT); }

({SP}?\"([^"\\\n]|{ES})*\"{WS}*)+   { MAKE_TOKEN(STRING_LITERAL); }

"..."					{ MAKE_TOKEN(ELLIPSIS); }
">>="					{ MAKE_TOKEN(RIGHT_ASSIGN); }
"<<="					{ MAKE_TOKEN(LEFT_ASSIGN); }
"+="					{ MAKE_TOKEN(ADD_ASSIGN); }
"-="					{ MAKE_TOKEN(SUB_ASSIGN); }
"*="					{ MAKE_TOKEN(MUL_ASSIGN); }
"/="					{ MAKE_TOKEN(DIV_ASSIGN); }
"%="					{ MAKE_TOKEN(MOD_ASSIGN); }
"&="					{ MAKE_TOKEN(AND_ASSIGN); }
"^="					{ MAKE_TOKEN(XOR_ASSIGN); }
"|="					{ MAKE_TOKEN(OR_ASSIGN); }
">>"					{ MAKE_TOKEN(RIGHT_OP); }
"<<"					{ MAKE_TOKEN(LEFT_OP); }
"++"					{ MAKE_TOKEN(INC_OP); }
"--"					{ MAKE_TOKEN(DEC_OP); }
"->"					{ MAKE_TOKEN(PTR_OP); }
"&&"					{ MAKE_TOKEN(AND_OP); }
"||"					{ MAKE_TOKEN(OR_OP); }
"<="					{ MAKE_TOKEN(LE_OP); }
">="					{ MAKE_TOKEN(GE_OP); }
"=="					{ MAKE_TOKEN(EQ_OP); }
"!="					{ MAKE_TOKEN(NE_OP); }

";"				{ MAKE_SYM_TOKEN(';'); }
("{"|"<%")		{ MAKE_SYM_TOKEN('{'); }
("}"|"%>")		{ MAKE_SYM_TOKEN('}'); }
","				{ MAKE_SYM_TOKEN(','); }
":"				{ MAKE_SYM_TOKEN(':'); }
"="				{ MAKE_SYM_TOKEN('='); }
"("				{ MAKE_SYM_TOKEN('('); }
")"				{ MAKE_SYM_TOKEN(')'); }
("["|"<:")		{ MAKE_SYM_TOKEN('['); }
("]"|":>")		{ MAKE_SYM_TOKEN(']'); }
"."				{ MAKE_SYM_TOKEN('.'); }
"&"				{ MAKE_SYM_TOKEN('&'); }
"!"				{ MAKE_SYM_TOKEN('!'); }
"~"				{ MAKE_SYM_TOKEN('~'); }
"-"				{ MAKE_SYM_TOKEN('-'); }
"+"				{ MAKE_SYM_TOKEN('+'); }
"*"				{ MAKE_SYM_TOKEN('*'); }
"/"				{ MAKE_SYM_TOKEN('/'); }
"%"				{ MAKE_SYM_TOKEN('%'); }
"<"				{ MAKE_SYM_TOKEN('<'); }
">"				{ MAKE_SYM_TOKEN('>'); }
"^"				{ MAKE_SYM_TOKEN('^'); }
"|"				{ MAKE_SYM_TOKEN('|'); }
"?"				{ MAKE_SYM_TOKEN('?'); }

{WS}+           { /* whitespace separates tokens */ }
.               { /* discard bad characters */ }

%%
